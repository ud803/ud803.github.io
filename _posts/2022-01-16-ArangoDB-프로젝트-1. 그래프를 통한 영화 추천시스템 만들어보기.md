---
layout: post
title: <아랑고DB> 프로젝트 1. 그래프를 통한 영화 추천시스템 만들어보기
categories: 아랑고DB
tags: [아랑고DB, 그래프DB, 추천시스템]
---

<div class="message">
아랑고DB는 배울만큼 배웠다! 이제는 실전만이 남아있다 🐱‍👤

마지막을 장식한 프로젝트에서는 Kaggle에서 가져온 영화 데이터를 아랑고DB에 맵핑하고, 실제 쿼리를 통해 추천 시스템을 만드는 것을 실습한다.

</div>

## 1. Kaggle이란

[Kaggle 캐글](https://www.kaggle.com/)은 데이터를 통해 현실의 문제를 해결하기 위한 플랫폼이다. 

데이터셋을 제공하고, 상금을 걸어 세계 각지에 있는 소중규모 팀들이 챌린지를 하는데, 원하는 결과값에 가장 가까운 팀이 상금을 차지하는 방식이다.

이러한 챌린지뿐만 아니라 수많은 데이터셋을 제공하고, 이러한 데이터셋을 다른 사람들은 어떻게 접근했고 분석했는지도 살펴볼 수 있다.

나는 그 중에서 **[Getting Started with a Movie Recommendation System](https://www.kaggle.com/ibtesama/getting-started-with-a-movie-recommendation-system/data)**이라는 데이터셋을 가져와 변형하였다.

내 글을 참고하여 자신만의 데이터셋을 찾아 맵핑해도 좋으나, 이러한 과정이 처음이라면 내 글을 그대로 따라하는 것을 추천한다.

나는 내가 사용할 데이터만 추려내어, 아래의 두 파일로 축약하였다.

- 영화에 관한 메타 데이터 파일 : [여기](https://raw.githubusercontent.com/ud803/ud803.github.io/main/public/csv/movies_metadata.csv)
- 사용자 평가에 관한 데이터 파일 : [여기](https://raw.githubusercontent.com/ud803/ud803.github.io/main/public/csv/ratings.csv)

두 파일을 로컬에 저장해도 좋고, 그냥 url을 코드에 넣어서 그때그때 다운로드해도 무방하다. 

## 2. 데이터 살펴보고 변형하기

일단 데이터를 불러와서, 우리가 원하는 입맛대로 변형해보자.

데이터는 csv 형태이므로 `pandas` 패키지의 `read_csv`를 사용한다. 

```python
import json
import pandas as pd

movies = pd.read_csv('https://raw.githubusercontent.com/ud803/ud803.github.io/main/public/csv/movies_metadata.csv', usecols=['genres', 'id', 'imdb_id', 'popularity', 'production_companies', 'vote_count', 'revenue', 'runtime', 'title', 'vote_average'], encoding = "ISO-8859-1", engine='python')
ratings = pd.read_csv('https://raw.githubusercontent.com/ud803/ud803.github.io/main/public/csv/ratings.csv')

print(movies.shape, ratings.shape)
#(45455, 10) (100004, 4)
```

`shape` 함수를 통해 데이터프레임의 사이즈를 보면, 각각 45455, 100004개의 행을 가진 것을 알 수 있다.

지금 내가 테스트하고 있는 AWS 서버는 t2.micro로 메모리가 1GB밖에 되지 않기 때문에, 데이터를 샘플링 할 예정이다.

```python
def int_changer(x):
    try:
        return int(x)
    except:
        return 0

#random_state를 똑같이 해줘야 나중에 데이터 뽑을 때 똑같이 나온다
ratings = ratings.sample(n=10000, random_state=116)
movies['id'] = movies['id'].apply(lambda x: int_changer(x))
movies = movies[movies['id'].isin(ratings['movieId'].unique())]

print(movies.shape, ratings.shape)
#(1286, 10) (10000, 4)
```

위 코드에서 해준 과정은 간단하다. 일단 평가 데이터에서 1만 개의 데이터만 추려내고, 그 1만 개의 데이터에서 사용된 영화들만 movies 데이터에서 추려냈다.

그리고 `int_changer`라는 함수를 굳이 만들어준 이유는, movies 데이터에서 `id`에 이상값이 껴있기 때문에 그냥 편하게 정제 하려고 한 것임!

```python
def json_handler(x):
    try:
        return [i['name'] for i in json.loads(x.replace('\'', '"'))]
    except:
        return []

movies['genres'] = movies['genres'].apply(lambda x: json_handler(x))
movies['production_companies'] = movies['production_companies'].apply(lambda x: json_handler(x))

# genres와 companies는 별도로 사용할 데이터이기 때문에, 단수형 이름으로 열 두 개를 더 복사해준다
movies['genre'] = movies['genres']
movies['production_company'] = movies['production_companies']

# explode를 통해 리스트 형태를 행으로 풀어준다
movies = movies.explode('genre').explode('production_company').fillna('')
```

마지막으로 가장 복잡한 단계를 거쳤다. 먼저 movies의 `genres` 필드가 문자열이기 때문에, `json` 패키지를 통해 json형태로 변환 -> 리스트 형으로 변환하였다.

그리고 `explode` 는 `pandas`의 메서드인데, 리스트 형태로 묶여있는 데이터를 `unnest` (또는 `unwind`) 해주는 역할이다.

즉, 1개의 행에서, {'a': [1, 2], 'b': 'hi'} 라는 데이터가 있었다면, {'a': 1, 'b': 'hi'}, {'a': 2, 'b': 'hi'} 두 개의 데이터로 분배해주는 역할을 한다.

## 3. 아랑고에 넣을 데이터 설계하기

이제 가장 재미있는 일만 남았다. 이 데이터들을 어떻게 아랑고DB에 맵핑할 것인가?

모든 데이터베이스가 마찬가지이지만, 일단 내가 데이터를 어떤 형태로 저장할 것이고, 어떻게 참조(쿼리)할 것인가를 구상해야 한다.

내 계획은 이렇다. 영화 추천 시스템이니까 당연히 영화(M)라는 버텍스가 있어야 하고, 사람(U)을 나타내는 버텍스가 또 있어야 한다.

그리고 사람(U)이 영화(M)를 평가(R)하는 엣지가 중간에 존재해야 한다. TMI이지만 Neo4j Cypher에서는 이를 (User) -[rated]-> (Movie) 와 같은 직관적인 방식으로 표현한다.

거기에 더해서, 나는 영화의 장르와 제작사의 데이터도 추천 시스템에 넣고 싶다. 결과적으로, 아래의 같은 7개의 컬렉션들이 생성되어야 한다.

- 버텍스 컬렉션 : 영화(Movie), 사람(User), 장르(Genre), 제작사(Production)
- 엣지 컬렉션 : (영화)-[rated]-(사람), (영화)-[belongs_to]-(장르), (영화)-[is_produced_by]-(제작사)


## 4. 아랑고에 데이터 맵핑하기

자 이제 데이터를 어떻게 넣으면 될까? 이제껏 배운 방식을 총동원하여 각각에 맞는 데이터를 넣어줘도 되지만, 우리는 이미 만들어진 패키지를 가져다 쓰면 된다.

바로 **[python-arango-mapper](https://github.com/ud803/python-arango-mapper)**라는 패키지이며, 내가 만들었다.. 😊

맵핑할 데이터에 대한 스키마를 지정해주면, 자동으로 데이터를 넣어준다.

우선 pip을 통해 패키지를 설치해주자.

```shell
pip install python-arango-mapper
```

<div class="tip">
각각의 타입을 주석으로 써두었으니, 다른 데이터에 적용할 사람들은 깃허브 페이지에 가서 해당 타입에 대한 가이드를 보면서 사용법을 익히길 바란다! 😘

아랑고DB를 사용하는 사람이라면 정말로 유용하게 사용할 수 있을 것이다!
</div>

```python
schemas = {
    # Type 1
    'Movie': {
        'type': ('vertex', 'unique_vertex'),
        'collection': 'Movie',
        'unique_key': ('id',),
        'fields': {
            'title': 'title',
            'runtime': 'runtime',
            'vote_average': 'vote_average',
            'popularity': 'popularity',
            'genres': 'genres',
            'production_companies': 'production_companies'
        },
        'index': [
            {'field' : ('runtime',), 'unique' : False, 'ttl' : False},
            {'field' : ('vote_average',), 'unique' : False, 'ttl' : False},
            {'field' : ('popularity',), 'unique' : False, 'ttl' : False}
        ]
    },
    # Type 1
    'Genre': {
        'type': ('vertex', 'unique_vertex'),
        'collection': 'Genre',
        'unique_key': ('genre',),
        'fields': {
            'genre': 'genre'
        },
        'index': [
            {'field' : ('genre',), 'unique' : True, 'ttl' : False}
        ]
    },
    # Type 1
    'Production': {
        'type': ('vertex', 'unique_vertex'),
        'collection': 'Production',
        'unique_key': ('production_company',),
        'fields': {
            'production_company': 'production_company'
        },
        'index': [
            {'field' : ('production_company',), 'unique' : True, 'ttl' : False}
        ]
    },
    # Type 1
    'User': {
        'type': ('vertex', 'unique_vertex'),
        'collection': 'User',
        'unique_key': ('userId',),
        'fields': {
            'user': 'userId'
        },
        'index': [
            {'field' : ('user',), 'unique' : True, 'ttl' : False}
        ]
    },

    
    # User - rated -> Movie
    # Type 3
    'rated': {
        'type': ('edge', 'unique_edge_on_event'),
        'collection': 'rated',
        'unique_key': ('timestamp',),
        '_from_collection': 'User',
        '_from': ('userId',),
        '_to_collection': 'Movie',
        '_to': ('movieId',),
        'fields': {
            'timestamp': 'timestamp',
            'rating': 'rating'
        },
        'index': []
    },

    # Movie - belongs_to -> Genre
    # Type 2
    'belongs_to': {
        'type': ('edge', 'unique_edge_btw_vertices'),
        'collection': 'belongs_to',
        '_from_collection': 'Movie',
        '_from': ('id',),
        '_to_collection': 'Genre',
        '_to': ('genre',),
        'fields': {
        },
        'index': []
    },

    # Movie - is_produced_by -> Production
    # Type 2
    'is_produced_by': {
        'type': ('edge', 'unique_edge_btw_vertices'),
        'collection': 'is_produced_by',
        '_from_collection': 'Movie',
        '_from': ('id',),
        '_to_collection': 'Production',
        '_to': ('production_company',),
        'fields': {
        },
        'index': []
    }
}
```

스키마가 복잡해보이지만, 한 번 세팅해두면 계속해서 손쉽게 사용할 수 있다. 

```python
from pam import client, database, converter

# ArangoDB에 연결
arango_conn = client.get_arango_conn(hosts="http://localhost:8529")
database_obj = database.create_and_get_database(arango_conn, 'movie_ratings', 'root', 'passwd')

# 데이터프레임을 딕셔너리의 리스트 형태로 바꿔준다
data_1 = movies.to_dict('records')
# 전체 스키마를 사용하는 것이 아니기 때문에 사용할 리스트를 지정해준다
data_1_map = ['Movie', 'Genre', 'Production', 'belongs_to', 'is_produced_by']
converter.arango_converter(data_1, database_obj, schemas, data_1_map)

# Data 2 Upload
data_2 = ratings.to_dict('records')
data_2_map = ['rated']
converter.arango_converter(data_2, database_obj, schemas, data_2_map)
```

위 코드만 실행시켜주면 데이터는 성공적으로 들어간다! 


## 5. 다음 단계는

이제 데이터를 모두 넣었다. `pam` 패키지를 통해 어떠한 데이터 종류든 손쉽게 그래프 형태로 맵핑이 가능하다!

다음 글에서는 실제 들어온 데이터를 가지고 이제껏 배워온 AQL을 뽐내는 시간을 가져보자. 

그래프 탐색도 하고, 통계도 뽑아보고, 최종적으로는 추천 시스템을 만들어 볼 예정이다.

아마 다음 글이 아랑고DB 시리즈의 마지막 글이 될 것 같다 😢 

애정을 가지고 작성해온 만큼, 유종의 미를 거둬야겠다!! 지금까지 글을 읽으며 따라와주신 분들께 감사하다는 말씀을 드리고 싶다 :)
