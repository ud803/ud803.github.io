---
layout: post
title: <아랑고DB> 프로젝트. 그래프를 통한 영화 추천시스템 만들어보기 2 (최종편)
categories: 아랑고DB
tags: [아랑고DB, 그래프DB, 추천시스템]
---

<div class="message">
정말 오래간만에 작성하는 글이다. 아랑고DB 관련 글을 진작 마무리했어야 했는데 그러지 못했다. 🤦🏻‍♂️

이번 글에서는 지난 글에 이어 그래프를 활용한 추천 시스템을 실습하려고 한다.
</div>

## 1. 들어가기에 앞서

일단 지난 시간에 아랑고DB에 넣어둔 데이터를 확인해보자. 보다 복잡한 분석을 위해서는 파이썬을 통해 아랑고DB에 AQL을 날려서 데이터를 주고받고 해야하지만 여기서는 최대한 간단한 형태의 추천 시스템을 실습할 것이기 때문에 오로지 AQL을 통해서만 결과를 낼 것이다.

[아랑고DB 웹 UI](http://localhost:8529/)로 들어가서 `movie_ratings` 데이터베이스를 선택한 후, 좌측의 QUERIES 메뉴를 클릭하자. 

웹UI 관련 설정이 기억나지 않거나 이슈가 있으면 [이 글](https://ud803.github.io/%EC%95%84%EB%9E%91%EA%B3%A0db/2021/11/02/ArangoDB-2-%EC%95%84%EB%9E%91%EA%B3%A0DB-%EC%84%B8%ED%8C%85%ED%95%98%EA%B8%B0-on-Ubuntu/)에서 Web UI 세팅 부분을 다시 살펴보자.

## 2. 데이터 살펴보기

이제 실제로 데이터가 잘 들어갔는지 확인해보자.

우선 각 컬렉션의 데이터 개수를 확인한다. COLLECTIONS에서 각 컬렉션을 들어가서 좌측 하단의 데이터 개수를 확인해도 되는데, 여기서는 AQL을 통해 확인해보겠다.

```sql
// AQL은 하나의 리턴만 하기 때문에 아래를 각각 실행시켜줘야 함에 주의
RETURN length(rated)  // 84942

RETURN length(User) // 1000

RETURN length(Movie) // 17763
```

유저는 천 명으로 제한했었기 때문에 딱 1000개의 레코드가 있고, 영화는 17763개, 그리고 평가는 84942개가 있다.

이번에는 유저별, 영화별, 년도별 평가의 개수를 확인해보자. 

```sql
// AQL에서 통계값을 뽑는 관련 함수는 없는 것 같다. 각각을 개별 계산해준다. 
LET rates = (
FOR e IN rated
    COLLECT
        user = Document(e._from).user
    AGGREGATE
        cnt = COUNT(1)
    RETURN {
        user,
        cnt
    }
)

RETURN {
    min: min(rates[*].cnt),
    max: max(rates[*].cnt),
    avg: avg(rates[*].cnt)
}
```

위 쿼리는 일단 유저별로 평가의 개수를 모아준 뒤에(`rates`), 이 배열에서 `cnt`의 최소, 최대, 평균값만을 다시 계산한 결과이다.

유저들은 최소 20개에서 최대 2500개(!)의 평가를 내렸고, 평균적으로 84개의 평가를 내렸다. 아마 애초에 Netflix Prize에 사용되었던 데이터이기 때문에 양질의 평가를 한 사람들만을 추려놓은 것이라 생각된다.

```sql
// 영화별 rating 개수
FOR e IN rated
    COLLECT
        movie = Document(e._to).name
    AGGREGATE
        cnt = COUNT(1)
    
    SORT cnt DESC
    
    RETURN {
        movie,
        cnt
    }
  ```

쿼리는 아까와 유사하다. 그룹을 해주는 기준만 영화 타이틀로 바뀌었을 뿐이다. 같은 통계를 내보면, 최소 1개의 평가가 있는 영화부터, 최대 640개의 평가가 있는 영화까지 다양하다. 평균적으로 22개의 평가가 있다.

오해하면 안 될 것이, 전체 Netflix의 평가가 아닌, 내가 임의로 선별한 아주 작은 데이터가 그렇다는 것이다.

```sql
// 이번에는 년도별로
FOR e IN rated
    COLLECT
        date = SUBSTRING(e.date, 0, 4)
    AGGREGATE
        cnt = COUNT(1)
    
    SORT cnt DESC
    
    RETURN {
        date,
        cnt
    }
```

얘는 따로 통계를 볼 필요가 없다. 위 쿼리만 실행해도 2000년~2005년 사이 년도별 개수가 나오기 때문이다. 확실히 오래된 데이터라 2005년 데이터가 가장 많다. 

## 3. 협업 필터링(Collaborative Filtering, CF)
이번 실습에서는 추천 시스템의 한 가지 방법인 협업 필터링을 사용한다. (간단히 CF라고 줄여서 부르겠다)

CF는 가장 널리 사용되는 기법 중 하나이고, 이름 그대로 주변 사람들의 정보를 이용하여 (협업, collaborate) 예측을 만들어내는 (filtering) 기법이다.

[위키피디아](https://en.wikipedia.org/wiki/Collaborative_filtering#Memory-based)의 예시를 가져와보면, CF의 기본 아이디어는 아래와 같다.

- 유저 A와 유저 B가 1번 주제에 대해 의견이 같다고 가정하자.
- 그럼 A는 임의의 유저보다, 또다른 2,3,4.. 주제에 대해서도 B와 의견이 같을 확률이 높을 것이다.

즉, 비슷한(similar) 유저일수록 취향이 비슷할 것이고, 그 점을 기반으로 추천 값을 만들어내는 것이다.

CF에도 여러가지 종류가 있는데, 크게는 메모리 기반(Memory-based or Neighborhood-based)과 모델 기반(Model-based)로 분류된다.
- Memory based CF : ‘메모리’ 기반에서는, **메모리에 주어진 ‘데이터’ 내에서** 여러 계산을 거쳐 추천 값을 생성한다.
- Model based CF : ‘모델’ 기반에서는, 주어진 ‘데이터’를 통해 **모델을 학습시켜서** 이 모델이 추천 값을 생성하도록 한다.

추천 시스템에 관해 공부하고, 설명할 내용은 정말 많이 있다. CF도 자세하게 들어갈 수 있고, 이 외의 추천 방법론, 그리고 평가가 implicit 할 때의 방법 등.. 다룰 내용이 많다. 이건 기회가 되면 따로 시리즈로 작성해보도록 해야겠다. 😃

## 4. 메모리 기반 CF

여기서는 메모리 기반 CF를 쓸 건데, 메모리 기반도 크게 두 가지 종류로 나뉜다.

A 유저의 아이템 B에 대한 평가를 예측한다고 할 때, 각각은 아래처럼 해석할 수 있다.

- User-based : A 유저와 비슷한 성향을 가진 다른 유저들이 B에 대해 어떤 평가를 내렸는지 종합해본다.
- Item-based : B 아이템과 비슷한 성향을 가진 다른 아이템들에 대해 A가 어떤 평가를 내렸는지 종합해본다. 

여기서는 user-based CF를 사용할 예정이다. 다양한 가정에 따라 다양한 수식을 적용할 수 있으니 함께 찬찬히 살펴보자.

### 1) CF with equal similarity

